// <auto-generated/>

#nullable enable

namespace Akbura.Language.Syntax.Green
{
    internal sealed partial class GreenIdentifierNameSyntax : global::Akbura.Language.Syntax.Green.GreenSimpleNameSyntax
    {
        public GreenIdentifierNameSyntax(GreenSyntaxToken Identifier, System.Collections.Immutable.ImmutableArray<global::Akbura.Language.Syntax.AkburaDiagnostic>? diagnostics, System.Collections.Immutable.ImmutableArray<global::Akbura.Language.Syntax.AkburaSyntaxAnnotation>? annotations) : base(Identifier, (ushort)global::Akbura.Language.Syntax.SyntaxKind.IdentifierName, diagnostics, annotations)
        {
            var flags = Flags;
            var fullWidth = FullWidth;

            AdjustWidthAndFlags(Identifier, ref fullWidth, ref flags);

            SlotCount = 1;
            FullWidth = fullWidth;
            Flags = flags;
        }

        public new GreenIdentifierNameSyntax WithIdentifier(GreenSyntaxToken Identifier)
        {
            return UpdateIdentifierNameSyntax(Identifier);
        }

        public override GreenSimpleNameSyntax UpdateSimpleName(GreenSyntaxToken Identifier)
        {
            return UpdateIdentifierNameSyntax(Identifier);
        }

        public GreenIdentifierNameSyntax UpdateIdentifierNameSyntax(GreenSyntaxToken Identifier)
        {
            if (this.Identifier == Identifier)
            {
                return this;
            }

            var newNode = GreenSyntaxFactory.IdentifierName(Identifier);
            var diagnostics = GetDiagnostics();

            if (!diagnostics.IsDefaultOrEmpty)
            {
                newNode = global::System.Runtime.CompilerServices.Unsafe.As<GreenIdentifierNameSyntax>(newNode.WithDiagnostics(diagnostics));
            }

            var annotations = GetAnnotations();
            if (!annotations.IsDefaultOrEmpty)
            {
                newNode = global::System.Runtime.CompilerServices.Unsafe.As<GreenIdentifierNameSyntax>(newNode.WithAnnotations(annotations));
            }

            return newNode;
        }

        public override GreenNode? GetSlot(int index)
        {
            return index switch
            {
                0 => this.Identifier,
                _ => null,
            };
        }

        public override AkburaSyntax CreateRed(AkburaSyntax? parent, int position)
        {
            return new global::Akbura.Language.Syntax.IdentifierNameSyntax(this, parent, position);
        }

        public override GreenNode WithDiagnostics(System.Collections.Immutable.ImmutableArray<global::Akbura.Language.Syntax.AkburaDiagnostic>? diagnostics)
        {
            return new GreenIdentifierNameSyntax(this.Identifier, diagnostics, GetAnnotations());
        }

        public override GreenNode WithAnnotations(System.Collections.Immutable.ImmutableArray<global::Akbura.Language.Syntax.AkburaSyntaxAnnotation>? annotations)
        {
            return new GreenIdentifierNameSyntax(this.Identifier, GetDiagnostics(), annotations);
        }

        public override void Accept(GreenSyntaxVisitor greenSyntaxVisitor)
        {
            greenSyntaxVisitor.VisitIdentifierName(this);
        }

        public override T? Accept<T>(GreenSyntaxVisitor<T> greenSyntaxVisitor) where T : default
        {
            return greenSyntaxVisitor.VisitIdentifierName(this);
        }

        public override TResult? Accept<TParameter, TResult>(GreenSyntaxVisitor<TParameter, TResult> greenSyntaxVisitor, TParameter argument) where TResult : default
        {
            return greenSyntaxVisitor.VisitIdentifierName(this, argument);
        }
    }

    internal static partial class GreenSyntaxFactory
    {
        public static GreenIdentifierNameSyntax IdentifierName(global::Akbura.Language.Syntax.Green.GreenSyntaxToken Identifier)
        {
            global::System.Diagnostics.Debug.Assert(Identifier != null);
            global::System.Diagnostics.Debug.Assert(
                Identifier!.Kind == global::Akbura.Language.Syntax.SyntaxKind.IdentifierToken ||
            false);

            var kind = global::Akbura.Language.Syntax.SyntaxKind.IdentifierName;
            int hash;
            var cache = System.Runtime.CompilerServices.Unsafe.As<GreenIdentifierNameSyntax?>(GreenNodeCache.TryGetNode((ushort)kind, Identifier, out hash));
            if (cache != null)
            {
                return cache;
            }
            
            var result = new GreenIdentifierNameSyntax(Identifier, diagnostics: null, annotations: null);

            if (hash > 0)
            {
                GreenNodeCache.AddNode(result, hash);
            }

            return result;
        }
    }

    internal partial class GreenSyntaxVisitor
    {
        public virtual void VisitIdentifierName(GreenIdentifierNameSyntax node)
        {
            DefaultVisit(node);
        }
    }

    internal partial class GreenSyntaxVisitor<TResult>
    {
        public virtual TResult? VisitIdentifierName(GreenIdentifierNameSyntax node)
        {
            return DefaultVisit(node);
        }
    }

    internal partial class GreenSyntaxVisitor<TParameter, TResult>
    {
        public virtual TResult? VisitIdentifierName(GreenIdentifierNameSyntax node, TParameter argument)
        {
            return DefaultVisit(node, argument);
        }
    }

    internal partial class GreenSyntaxRewriter
    {
        public override GreenNode? VisitIdentifierName(GreenIdentifierNameSyntax node)
        {
            return node.UpdateIdentifierNameSyntax((GreenSyntaxToken)VisitToken(node.Identifier));
        }
    }
}


namespace Akbura.Language.Syntax
{
    internal sealed partial class IdentifierNameSyntax : global::Akbura.Language.Syntax.SimpleNameSyntax
    {


        public IdentifierNameSyntax(global::Akbura.Language.Syntax.Green.GreenIdentifierNameSyntax greenNode, global::Akbura.Language.Syntax.AkburaSyntax? parent, int position) : base(greenNode, parent, position)
        {
        }

        internal new global::Akbura.Language.Syntax.Green.GreenIdentifierNameSyntax Green => System.Runtime.CompilerServices.Unsafe.As<global::Akbura.Language.Syntax.Green.GreenIdentifierNameSyntax>(base.Green);

        public override global::Akbura.Language.Syntax.SyntaxToken Identifier => new(this, this.Green.Identifier, GetChildPosition(0), GetChildIndex(0));

        public override global::Akbura.Language.Syntax.AkburaSyntax? GetNodeSlot(int index)
        {
            return index switch
            {
                _ => null,
            };
        }

        public override AkburaSyntax? GetCachedSlot(int index)
        {
            return index switch
            {
                _ => null,
            };
        }

        public override SimpleNameSyntax UpdateSimpleName(SyntaxToken Identifier)
        {
            return UpdateIdentifierNameSyntax(Identifier);
        }

        public new IdentifierNameSyntax WithIdentifier(SyntaxToken Identifier)
        {
            return UpdateIdentifierNameSyntax(Identifier);
        }

        public IdentifierNameSyntax UpdateIdentifierNameSyntax(SyntaxToken Identifier)
        {
            if (this.Identifier == Identifier)
            {
                return this;
            }

            var newNode = SyntaxFactory.IdentifierName(Identifier);

            var annotations = this.GetAnnotations();

            if (!annotations.IsDefaultOrEmpty)
            {
                newNode = (IdentifierNameSyntax)newNode.WithAnnotations(annotations);
            }

            var diagnostics = this.GetDiagnostics();

            if (!diagnostics.IsDefaultOrEmpty)
            {
                newNode = (IdentifierNameSyntax)newNode.WithDiagnostics(diagnostics);
            }

            return newNode;
        }

        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitIdentifierName(this);
        }

        public override TResult? Accept<TResult>(SyntaxVisitor<TResult> visitor) where TResult : default
        {
            return visitor.VisitIdentifierName(this);
        }

        public override TResult? Accept<TParameter, TResult>(SyntaxVisitor<TParameter, TResult> visitor, TParameter argument) where TResult : default
        {
            return visitor.VisitIdentifierName(this, argument);
        }
    }

    internal static partial class SyntaxFactory
    {

        internal static IdentifierNameSyntax IdentifierName(SyntaxToken identifier)
        {
            if (identifier.Node is not global::Akbura.Language.Syntax.Green.GreenSyntaxToken)
            {
                ThrowHelper.ThrowArgumentException(nameof(identifier), message: $"identifier must be a GreenSyntaxToken. Use SyntaxFactory.Token(...)?");
            }

            if (identifier.RawKind != (ushort)SyntaxKind.IdentifierToken)
            {
                ThrowHelper.ThrowArgumentException(nameof(identifier), message: $"identifier must be SyntaxKind.IdentifierToken");
            }

            var green = global::Akbura.Language.Syntax.Green.GreenSyntaxFactory.IdentifierName(System.Runtime.CompilerServices.Unsafe.As<global::Akbura.Language.Syntax.Green.GreenSyntaxToken>(identifier.Node!));
            return System.Runtime.CompilerServices.Unsafe.As<IdentifierNameSyntax>(green.CreateRed());
        }
    }

    internal partial class SyntaxVisitor
    {
        public virtual void VisitIdentifierName(IdentifierNameSyntax node)
        {
            DefaultVisit(node);
        }
    }

    internal partial class SyntaxVisitor<TResult>
    {
        public virtual TResult? VisitIdentifierName(IdentifierNameSyntax node)
        {
            return DefaultVisit(node);
        }
    }

    internal partial class SyntaxVisitor<TParameter, TResult>
    {
        public virtual TResult? VisitIdentifierName(IdentifierNameSyntax node, TParameter argument)
        {
            return DefaultVisit(node, argument);
        }
    }

    internal partial class SyntaxRewriter
    {
        public override AkburaSyntax? VisitIdentifierName(IdentifierNameSyntax node)
        {
            return node.UpdateIdentifierNameSyntax((SyntaxToken)VisitToken(node.Identifier));
        }
    }
}
#nullable restore