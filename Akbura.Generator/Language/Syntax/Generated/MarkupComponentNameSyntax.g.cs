// <auto-generated/>

#nullable enable

using Akbura.Pools;
using System;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using CSharp = Microsoft.CodeAnalysis.CSharp;
using CSharpSyntaxFactory = Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace Akbura.Language.Syntax.Green
{
    internal abstract partial class GreenMarkupComponentNameSyntax : global::Akbura.Language.Syntax.Green.GreenNode
    {
        protected GreenMarkupComponentNameSyntax(
            ushort kind,
            ImmutableArray<global::Akbura.Language.Syntax.AkburaDiagnostic>? diagnostics,
            ImmutableArray<global::Akbura.Language.Syntax.AkburaSyntaxAnnotation>? annotations)
            : base(kind, diagnostics, annotations)
        {
        }

        public override global::Akbura.Language.Syntax.Green.GreenNode? GetSlot(int index)
        {
            return null;
        }
    }
}

namespace Akbura.Language.Syntax
{
    internal abstract partial class MarkupComponentNameSyntax : global::Akbura.Language.Syntax.AkburaSyntax
    {
        protected MarkupComponentNameSyntax(
            global::Akbura.Language.Syntax.Green.GreenMarkupComponentNameSyntax greenNode,
            global::Akbura.Language.Syntax.AkburaSyntax? parent,
            int position)
            : base(greenNode, parent, position)
        {
        }

        internal new global::Akbura.Language.Syntax.Green.GreenMarkupComponentNameSyntax Green
            => Unsafe.As<global::Akbura.Language.Syntax.Green.GreenMarkupComponentNameSyntax>(base.Green);

        public override global::Akbura.Language.Syntax.AkburaSyntax? GetNodeSlot(int index)
        {
            return null;
        }

        public override global::Akbura.Language.Syntax.AkburaSyntax? GetCachedSlot(int index)
        {
            return null;
        }

        public new MarkupComponentNameSyntax WithLeadingTrivia(SyntaxTriviaList trivia)
        {
            return (MarkupComponentNameSyntax)base.WithLeadingTrivia(trivia);
        }

        public new MarkupComponentNameSyntax WithTrailingTrivia(SyntaxTriviaList trivia)
        {
            return (MarkupComponentNameSyntax)base.WithTrailingTrivia(trivia);
        }

        public CSharp.Syntax.TypeSyntax ToCSharp()
        {
            if (Kind == SyntaxKind.MarkupSimpleComponentNameSyntax)
            {
                var simpleComponentName = (MarkupSimpleComponentNameSyntax)this;

                return CSharpSyntaxFactory.IdentifierName(
                    CSharpSyntaxFactory.Identifier(simpleComponentName.Name.Identifier.ToString())
                );
            }

            if (Kind == SyntaxKind.MarkupQualifiedComponentNameSyntax)
            {
                var qualifiedComponentName = (MarkupQualifiedComponentNameSyntax)this;

                return BuildQualifiedNameFromSegments(
                    qualifiedComponentName.Name.Segments,
                    qualifiedComponentName.AliasQualifier
                );
            }

            throw new NotSupportedException($"Cannot convert {Kind} to CSharp TypeSyntax.");
        }

        private static CSharp.Syntax.NameSyntax BuildQualifiedNameFromSegments(
            SeparatedSyntaxList<MarkupNameSegmentSyntax> segments,
            MarkupAliasQualifierSyntax? aliasQualifier)
        {
            if (segments.Count == 0)
            {
                throw new InvalidOperationException("Qualified component name must have at least one segment.");
            }

            // First segment must be SimpleNameSyntax for AliasQualifiedName.
            var firstSegmentName = BuildSimpleNameFromSegment(segments[0]);

            CSharp.Syntax.NameSyntax currentName;

            if (aliasQualifier is not null)
            {
                currentName = CSharpSyntaxFactory.AliasQualifiedName(
                    CSharpSyntaxFactory.IdentifierName(
                        aliasQualifier.Alias.Identifier.ToString()
                    ),
                    firstSegmentName
                );
            }
            else
            {
                currentName = firstSegmentName;
            }

            // Remaining segments: always QualifiedName(left, rightSimple)
            for (var index = 1; index < segments.Count; index++)
            {
                var rightSegmentName = BuildSimpleNameFromSegment(segments[index]);

                currentName = CSharpSyntaxFactory.QualifiedName(
                    currentName,
                    rightSegmentName
                );
            }

            return currentName;
        }

        private static CSharp.Syntax.SimpleNameSyntax BuildSimpleNameFromSegment(MarkupNameSegmentSyntax segment)
        {
            if (segment.Kind == SyntaxKind.MarkupIdentifierNameSegmentSyntax)
            {
                var identifierSegment = (MarkupIdentifierNameSegmentSyntax)segment;

                return CSharpSyntaxFactory.IdentifierName(
                    CSharpSyntaxFactory.Identifier(identifierSegment.Name.Identifier.ToString())
                );
            }

            if (segment.Kind == SyntaxKind.MarkupGenericNameSegmentSyntax)
            {
                var genericSegment = (MarkupGenericNameSegmentSyntax)segment;

                using var typeArgumentsBuilder = ImmutableArrayBuilder<CSharp.Syntax.TypeSyntax>.Rent();

                foreach (var typeArgument in genericSegment.GenericArgs.Arguments)
                {
                    typeArgumentsBuilder.Add(typeArgument.ToCSharp());
                }

                var typeArguments = typeArgumentsBuilder.ToImmutable();

                var typeArgumentList = CSharpSyntaxFactory.TypeArgumentList(
                    CSharpSyntaxFactory.SeparatedList(typeArguments)
                );

                return CSharpSyntaxFactory.GenericName(
                    CSharpSyntaxFactory.Identifier(genericSegment.Name.Identifier.ToString()),
                    typeArgumentList
                );
            }

            throw new NotSupportedException($"Unsupported markup name segment kind: {segment.Kind}");
        }
    }
}

#nullable restore