// <auto-generated/>

#nullable enable

using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Collections.Immutable;
using CSharp = Microsoft.CodeAnalysis.CSharp;
using CSharpSyntaxFactory = Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace Akbura.Language.Syntax.Green
{
    internal abstract partial class GreenMarkupComponentNameSyntax : global::Akbura.Language.Syntax.Green.GreenNode
    {
        protected GreenMarkupComponentNameSyntax(
            ushort kind,
            ImmutableArray<global::Akbura.Language.Syntax.AkburaDiagnostic>? diagnostics,
            ImmutableArray<global::Akbura.Language.Syntax.AkburaSyntaxAnnotation>? annotations)
            : base(kind, diagnostics, annotations)
        {
        }

        public override global::Akbura.Language.Syntax.Green.GreenNode? GetSlot(int index)
        {
            return null;
        }
    }
}

namespace Akbura.Language.Syntax
{
    internal abstract partial class MarkupComponentNameSyntax : global::Akbura.Language.Syntax.AkburaSyntax
    {
        protected MarkupComponentNameSyntax(
            global::Akbura.Language.Syntax.Green.GreenMarkupComponentNameSyntax greenNode,
            global::Akbura.Language.Syntax.AkburaSyntax? parent,
            int position)
            : base(greenNode, parent, position)
        {
        }

        internal new global::Akbura.Language.Syntax.Green.GreenMarkupComponentNameSyntax Green
            => Unsafe.As<global::Akbura.Language.Syntax.Green.GreenMarkupComponentNameSyntax>(base.Green);

        public override global::Akbura.Language.Syntax.AkburaSyntax? GetNodeSlot(int index)
        {
            return null;
        }

        public override global::Akbura.Language.Syntax.AkburaSyntax? GetCachedSlot(int index)
        {
            return null;
        }

        public new MarkupComponentNameSyntax WithLeadingTrivia(SyntaxTriviaList trivia)
        {
            return (MarkupComponentNameSyntax)base.WithLeadingTrivia(trivia);
        }

        public new MarkupComponentNameSyntax WithTrailingTrivia(SyntaxTriviaList trivia)
        {
            return (MarkupComponentNameSyntax)base.WithTrailingTrivia(trivia);
        }

        public CSharp.Syntax.TypeSyntax ToCSharp()
        {
            if(Kind == SyntaxKind.MarkupSimpleComponentNameSyntax)
            {
                var simpleName = (SimpleNameSyntax)GetRequiredNodeSlot(0);

                return CSharpSyntaxFactory.IdentifierName(
                    CSharpSyntaxFactory.Identifier(simpleName.Identifier.ToString())
                );
            }

            if(Kind == SyntaxKind.MarkupQualifiedComponentNameSyntax)
            {
                var qualified = (MarkupQualifiedComponentNameSyntax)this;

                // 1. Build base name: Namespace.Type or Namespace.Sub.Type
                CSharp.Syntax.NameSyntax nameSyntax = BuildQualifiedName(qualified.Name);

                // 2. Apply generics if present
                if (qualified.GenericArgs is not null)
                {
                    nameSyntax = ApplyGenericArguments(nameSyntax, qualified.GenericArgs);
                }

                // 3. Apply alias if present: alias::Name
                if (qualified.AliasQualifier is not null)
                {
                    nameSyntax = CSharpSyntaxFactory.AliasQualifiedName(
                        CSharpSyntaxFactory.IdentifierName(
                            qualified.AliasQualifier.Alias.Identifier.ToString()
                        ),
                        (CSharp.Syntax.SimpleNameSyntax)nameSyntax
                    );
                }

                return nameSyntax;
            }

            throw new NotSupportedException($"Cannot convert {Kind} to CSharp TypeSyntax.");
        }

        private static CSharp.Syntax.NameSyntax BuildQualifiedName(MarkupQualifiedNameSyntax name)
        {
            Debug.Assert(name.Parts.Count > 0);

            CSharp.Syntax.NameSyntax current =
                CSharpSyntaxFactory.IdentifierName(
                    name.Parts[0].Identifier.ToString()
                );

            for (var i = 1; i < name.Parts.Count; i++)
            {
                current = CSharpSyntaxFactory.QualifiedName(
                    current,
                    CSharpSyntaxFactory.IdentifierName(
                        name.Parts[i].Identifier.ToString()
                    )
                );
            }

            return current;
        }

        private static CSharp.Syntax.NameSyntax ApplyGenericArguments(
            CSharp.Syntax.NameSyntax name,
            MarkupGenericArgumentListSyntax genericArgs)
        {
            var arguments = ImmutableArray.CreateBuilder<CSharp.Syntax.TypeSyntax>();

            foreach (var arg in genericArgs.Arguments)
            {
                arguments.Add(arg.ToCSharp());
            }

            var typeArgumentList = CSharpSyntaxFactory.TypeArgumentList(
                CSharpSyntaxFactory.SeparatedList(arguments)
            );

            // If name is already qualified: Namespace.Type
            if (name is CSharp.Syntax.QualifiedNameSyntax qualified)
            {
                return CSharpSyntaxFactory.QualifiedName(
                    qualified.Left,
                    CSharpSyntaxFactory.GenericName(
                        qualified.Right.Identifier,
                        typeArgumentList
                    )
                );
            }

            // Simple generic name: Type<T>
            if (name is CSharp.Syntax.IdentifierNameSyntax identifier)
            {
                return CSharpSyntaxFactory.GenericName(
                    identifier.Identifier,
                    typeArgumentList
                );
            }

            throw new NotSupportedException("Unsupported name kind for generic application.");
        }
    }
}

#nullable restore