// <auto-generated/>

#nullable enable

using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Collections.Immutable;
using Akbura.Language.Syntax.Green;

namespace Akbura.Language.Syntax.Green
{
    internal sealed partial class GreenMarkupStartTagSyntax : global::Akbura.Language.Syntax.Green.GreenMarkupSyntaxNodeSyntax
    {
        public readonly global::Akbura.Language.Syntax.Green.GreenSyntaxToken LessToken;
        public readonly global::Akbura.Language.Syntax.Green.GreenSimpleNameSyntax Name;
        public readonly global::Akbura.Language.Syntax.Green.GreenNode? _attributes;
        public readonly global::Akbura.Language.Syntax.Green.GreenSyntaxToken CloseToken;

        public GreenMarkupStartTagSyntax(
            global::Akbura.Language.Syntax.Green.GreenSyntaxToken lessToken,
            global::Akbura.Language.Syntax.Green.GreenSimpleNameSyntax name,
            global::Akbura.Language.Syntax.Green.GreenNode? attributes,
            global::Akbura.Language.Syntax.Green.GreenSyntaxToken closeToken,
            ImmutableArray<global::Akbura.Language.Syntax.AkburaDiagnostic>? diagnostics,
            ImmutableArray<global::Akbura.Language.Syntax.AkburaSyntaxAnnotation>? annotations)
            : base((ushort)global::Akbura.Language.Syntax.SyntaxKind.MarkupStartTagSyntax, diagnostics, annotations)
        {
            this.LessToken = lessToken;
            this.Name = name;
            this._attributes = attributes;
            this.CloseToken = closeToken;

            AkburaDebug.Assert(this.LessToken != null);
            AkburaDebug.Assert(this.Name != null);
            AkburaDebug.Assert(this.CloseToken != null);

            AkburaDebug.Assert(
                this.LessToken.Kind == global::Akbura.Language.Syntax.SyntaxKind.LessThanToken ||
                false);

            AkburaDebug.Assert(
                this.CloseToken.Kind == global::Akbura.Language.Syntax.SyntaxKind.GreaterThanToken ||
                this.CloseToken.Kind == global::Akbura.Language.Syntax.SyntaxKind.SlashGreaterToken ||
                false);

            var flags = Flags;
            var fullWidth = FullWidth;

            AdjustWidthAndFlags(LessToken, ref fullWidth, ref flags);
            AdjustWidthAndFlags(Name, ref fullWidth, ref flags);

            if (_attributes != null)
            {
                AdjustWidthAndFlags(_attributes, ref fullWidth, ref flags);
            }

            AdjustWidthAndFlags(CloseToken, ref fullWidth, ref flags);

            SlotCount = 4;
            FullWidth = fullWidth;
            Flags = flags;
        }

        public GreenSyntaxList<GreenMarkupAttributeSyntax> Attributes => new(_attributes);

        public GreenMarkupStartTagSyntax UpdateMarkupStartTagSyntax(
            global::Akbura.Language.Syntax.Green.GreenSyntaxToken lessToken,
            global::Akbura.Language.Syntax.Green.GreenSimpleNameSyntax name,
            global::Akbura.Language.Syntax.Green.GreenNode? attributes,
            global::Akbura.Language.Syntax.Green.GreenSyntaxToken closeToken)
        {
            if (this.LessToken == lessToken &&
                this.Name == name &&
                this._attributes == attributes &&
                this.CloseToken == closeToken)
            {
                return this;
            }

            var newNode = GreenSyntaxFactory.MarkupStartTagSyntax(
                lessToken,
                name,
                attributes.ToGreenList<GreenMarkupAttributeSyntax>(),
                closeToken);

            var diagnostics = GetDiagnostics();
            if (!diagnostics.IsDefaultOrEmpty)
            {
                newNode = Unsafe.As<GreenMarkupStartTagSyntax>(newNode.WithDiagnostics(diagnostics));
            }

            var annotations = GetAnnotations();
            if (!annotations.IsDefaultOrEmpty)
            {
                newNode = Unsafe.As<GreenMarkupStartTagSyntax>(newNode.WithAnnotations(annotations));
            }

            return newNode;
        }

        public GreenMarkupStartTagSyntax WithLessToken(global::Akbura.Language.Syntax.Green.GreenSyntaxToken lessToken)
        {
            return UpdateMarkupStartTagSyntax(lessToken, this.Name, this._attributes, this.CloseToken);
        }

        public GreenMarkupStartTagSyntax WithName(global::Akbura.Language.Syntax.Green.GreenSimpleNameSyntax name)
        {
            return UpdateMarkupStartTagSyntax(this.LessToken, name, this._attributes, this.CloseToken);
        }

        public GreenMarkupStartTagSyntax WithAttributes(global::Akbura.Language.Syntax.Green.GreenSyntaxList<GreenMarkupAttributeSyntax> attributes)
        {
            return UpdateMarkupStartTagSyntax(this.LessToken, this.Name, attributes.Node, this.CloseToken);
        }

        public GreenMarkupStartTagSyntax WithCloseToken(global::Akbura.Language.Syntax.Green.GreenSyntaxToken closeToken)
        {
            return UpdateMarkupStartTagSyntax(this.LessToken, this.Name, this._attributes, closeToken);
        }

        public override global::Akbura.Language.Syntax.Green.GreenNode? GetSlot(int index)
        {
            return index switch
            {
                0 => LessToken,
                1 => Name,
                2 => _attributes,
                3 => CloseToken,
                _ => null,
            };
        }

        public override global::Akbura.Language.Syntax.AkburaSyntax CreateRed(global::Akbura.Language.Syntax.AkburaSyntax? parent, int position)
        {
            return new global::Akbura.Language.Syntax.MarkupStartTagSyntax(this, parent, position);
        }

        public override global::Akbura.Language.Syntax.Green.GreenNode WithDiagnostics(ImmutableArray<global::Akbura.Language.Syntax.AkburaDiagnostic>? diagnostics)
        {
            return new GreenMarkupStartTagSyntax(this.LessToken, this.Name, this._attributes, this.CloseToken, diagnostics, GetAnnotations());
        }

        public override global::Akbura.Language.Syntax.Green.GreenNode WithAnnotations(ImmutableArray<global::Akbura.Language.Syntax.AkburaSyntaxAnnotation>? annotations)
        {
            return new GreenMarkupStartTagSyntax(this.LessToken, this.Name, this._attributes, this.CloseToken, GetDiagnostics(), annotations);
        }

        public override void Accept(GreenSyntaxVisitor greenSyntaxVisitor)
        {
            greenSyntaxVisitor.VisitMarkupStartTagSyntax(this);
        }

        public override TResult? Accept<TResult>(GreenSyntaxVisitor<TResult> greenSyntaxVisitor) where TResult : default
        {
            return greenSyntaxVisitor.VisitMarkupStartTagSyntax(this);
        }

        public override TResult? Accept<TParameter, TResult>(GreenSyntaxVisitor<TParameter, TResult> greenSyntaxVisitor, TParameter argument) where TResult : default
        {
            return greenSyntaxVisitor.VisitMarkupStartTagSyntax(this, argument);
        }
    }

    internal static partial class GreenSyntaxFactory
    {
        public static GreenMarkupStartTagSyntax MarkupStartTagSyntax(
            global::Akbura.Language.Syntax.Green.GreenSyntaxToken lessToken,
            global::Akbura.Language.Syntax.Green.GreenSimpleNameSyntax name,
            global::Akbura.Language.Syntax.Green.GreenSyntaxList<GreenMarkupAttributeSyntax> attributes,
            global::Akbura.Language.Syntax.Green.GreenSyntaxToken closeToken)
        {
            AkburaDebug.Assert(lessToken != null);
            AkburaDebug.Assert(name != null);
            AkburaDebug.Assert(closeToken != null);

            AkburaDebug.Assert(
                lessToken!.Kind == global::Akbura.Language.Syntax.SyntaxKind.LessThanToken ||
                false);

            AkburaDebug.Assert(
                closeToken!.Kind == global::Akbura.Language.Syntax.SyntaxKind.GreaterThanToken ||
                closeToken!.Kind == global::Akbura.Language.Syntax.SyntaxKind.SlashGreaterToken ||
                false);


            var result = new GreenMarkupStartTagSyntax(
                lessToken,
                name,
                attributes.Node,
                closeToken,
                diagnostics: null,
                annotations: null);

            return result;
        }
    }

    internal partial class GreenSyntaxVisitor
    {
        public virtual void VisitMarkupStartTagSyntax(GreenMarkupStartTagSyntax node)
        {
            DefaultVisit(node);
        }
    }

    internal partial class GreenSyntaxVisitor<TResult>
    {
        public virtual TResult? VisitMarkupStartTagSyntax(GreenMarkupStartTagSyntax node)
        {
            return DefaultVisit(node);
        }
    }

    internal partial class GreenSyntaxVisitor<TParameter, TResult>
    {
        public virtual TResult? VisitMarkupStartTagSyntax(GreenMarkupStartTagSyntax node, TParameter argument)
        {
            return DefaultVisit(node, argument);
        }
    }

    internal partial class GreenSyntaxRewriter
    {
        public override GreenNode? VisitMarkupStartTagSyntax(GreenMarkupStartTagSyntax node)
        {
            return node.UpdateMarkupStartTagSyntax(
                (GreenSyntaxToken)VisitToken(node.LessToken),
                (GreenSimpleNameSyntax)Visit(node.Name)!,
                VisitList(node.Attributes).Node,
                (GreenSyntaxToken)VisitToken(node.CloseToken));
        }
    }
}

namespace Akbura.Language.Syntax
{
    internal sealed partial class MarkupStartTagSyntax : global::Akbura.Language.Syntax.MarkupSyntaxNodeSyntax
    {
        private AkburaSyntax? _name;
        private AkburaSyntax? _attributes;

        public MarkupStartTagSyntax(
            global::Akbura.Language.Syntax.Green.GreenMarkupStartTagSyntax greenNode,
            global::Akbura.Language.Syntax.AkburaSyntax? parent,
            int position)
            : base(greenNode, parent, position)
        {
        }

        internal new global::Akbura.Language.Syntax.Green.GreenMarkupStartTagSyntax Green
            => Unsafe.As<global::Akbura.Language.Syntax.Green.GreenMarkupStartTagSyntax>(base.Green);

        public SyntaxToken LessToken
            => new(this, this.Green.LessToken, GetChildPosition(0), GetChildIndex(0));

        public SimpleNameSyntax Name
            => (SimpleNameSyntax)GetRed(ref _name, 1)!;

        public SyntaxList<MarkupAttributeSyntax> Attributes
        {
            get
            {
                var red = GetRed(ref this._attributes, 2);
                return new SyntaxList<MarkupAttributeSyntax>(red);
            }
        }

        public SyntaxToken CloseToken
            => new(this, this.Green.CloseToken, GetChildPositionFromEnd(1), GetChildIndex(3));

        public MarkupStartTagSyntax UpdateMarkupStartTagSyntax(
            SyntaxToken lessToken,
            SimpleNameSyntax name,
            SyntaxList<MarkupAttributeSyntax> attributes,
            SyntaxToken closeToken)
        {
            if (this.LessToken == lessToken &&
                this.Name == name &&
                this.Attributes == attributes &&
                this.CloseToken == closeToken)
            {
                return this;
            }

            var newNode = SyntaxFactory.MarkupStartTagSyntax(
                lessToken,
                name,
                attributes,
                closeToken);

            var annotations = this.GetAnnotations();
            if (!annotations.IsDefaultOrEmpty)
            {
                newNode = (MarkupStartTagSyntax)newNode.WithAnnotations(annotations);
            }

            var diagnostics = this.GetDiagnostics();
            if (!diagnostics.IsDefaultOrEmpty)
            {
                newNode = (MarkupStartTagSyntax)newNode.WithDiagnostics(diagnostics);
            }

            return newNode;
        }

        public MarkupStartTagSyntax WithLessToken(SyntaxToken lessToken)
        {
            return UpdateMarkupStartTagSyntax(lessToken, this.Name, this.Attributes, this.CloseToken);
        }

        public MarkupStartTagSyntax WithName(SimpleNameSyntax name)
        {
            if (name is null)
            {
                ThrowHelper.ThrowArgumentNullException(nameof(name));
            }

            return UpdateMarkupStartTagSyntax(this.LessToken, name, this.Attributes, this.CloseToken);
        }

        public MarkupStartTagSyntax WithAttributes(SyntaxList<MarkupAttributeSyntax> attributes)
        {
            return UpdateMarkupStartTagSyntax(this.LessToken, this.Name, attributes, this.CloseToken);
        }

        public MarkupStartTagSyntax WithCloseToken(SyntaxToken closeToken)
        {
            return UpdateMarkupStartTagSyntax(this.LessToken, this.Name, this.Attributes, closeToken);
        }

        public override global::Akbura.Language.Syntax.AkburaSyntax? GetNodeSlot(int index)
        {
            return index switch
            {
                1 => GetRed(ref _name, 1),
                2 => GetRed(ref _attributes, 2),
                _ => null,
            };
        }

        public override global::Akbura.Language.Syntax.AkburaSyntax? GetCachedSlot(int index)
        {
            return index switch
            {
                1 => _name,
                2 => _attributes,
                _ => null,
            };
        }

        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitMarkupStartTagSyntax(this);
        }

        public override TResult? Accept<TResult>(SyntaxVisitor<TResult> visitor) where TResult : default
        {
            return visitor.VisitMarkupStartTagSyntax(this);
        }

        public override TResult? Accept<TParameter, TResult>(SyntaxVisitor<TParameter, TResult> visitor, TParameter argument) where TResult : default
        {
            return visitor.VisitMarkupStartTagSyntax(this, argument);
        }
    }

    internal static partial class SyntaxFactory
    {
        internal static MarkupStartTagSyntax MarkupStartTagSyntax(
            SyntaxToken lessToken,
            SimpleNameSyntax name,
            SyntaxList<MarkupAttributeSyntax> attributes,
            SyntaxToken closeToken)
        {
            if (lessToken.Node is not global::Akbura.Language.Syntax.Green.GreenSyntaxToken)
            {
                ThrowHelper.ThrowArgumentException(nameof(lessToken), message: $"lessToken must be a GreenSyntaxToken. Use SyntaxFactory.Token(...)?");
            }

            if (closeToken.Node is not global::Akbura.Language.Syntax.Green.GreenSyntaxToken)
            {
                ThrowHelper.ThrowArgumentException(nameof(closeToken), message: $"closeToken must be a GreenSyntaxToken. Use SyntaxFactory.Token(...)?");
            }

            if (lessToken.RawKind != (ushort)SyntaxKind.LessThanToken)
            {
                ThrowHelper.ThrowArgumentException(nameof(lessToken), message: $"lessToken must be SyntaxKind.LessThanToken");
            }

            if (closeToken.RawKind != (ushort)SyntaxKind.GreaterThanToken &&
                closeToken.RawKind != (ushort)SyntaxKind.SlashGreaterToken)
            {
                ThrowHelper.ThrowArgumentException(nameof(closeToken), message: $"closeToken must be SyntaxKind.GreaterThanToken or SyntaxKind.SlashGreaterToken");
            }

            if (name is null)
            {
                ThrowHelper.ThrowArgumentNullException(nameof(name));
            }

            if (attributes != default && attributes.Node?.Green is not GreenNode)
            {
                ThrowHelper.ThrowArgumentException(nameof(attributes), message: $"attributes must be backed by a GreenSyntaxList.");
            }

            var green = global::Akbura.Language.Syntax.Green.GreenSyntaxFactory.MarkupStartTagSyntax(
                Unsafe.As<global::Akbura.Language.Syntax.Green.GreenSyntaxToken>(lessToken.Node!),
                name.Green,
                attributes.ToGreenList<GreenMarkupAttributeSyntax, MarkupAttributeSyntax>(),
                Unsafe.As<global::Akbura.Language.Syntax.Green.GreenSyntaxToken>(closeToken.Node!));

            return Unsafe.As<MarkupStartTagSyntax>(green.CreateRed(null, 0));
        }
    }

    internal partial class SyntaxVisitor
    {
        public virtual void VisitMarkupStartTagSyntax(MarkupStartTagSyntax node)
        {
            DefaultVisit(node);
        }
    }

    internal partial class SyntaxVisitor<TResult>
    {
        public virtual TResult? VisitMarkupStartTagSyntax(MarkupStartTagSyntax node)
        {
            return DefaultVisit(node);
        }
    }

    internal partial class SyntaxVisitor<TParameter, TResult>
    {
        public virtual TResult? VisitMarkupStartTagSyntax(MarkupStartTagSyntax node, TParameter argument)
        {
            return DefaultVisit(node, argument);
        }
    }

    internal partial class SyntaxRewriter
    {
        public override AkburaSyntax? VisitMarkupStartTagSyntax(MarkupStartTagSyntax node)
        {
            return node.UpdateMarkupStartTagSyntax(
                VisitToken(node.LessToken),
                (SimpleNameSyntax)Visit(node.Name)!,
                VisitList(node.Attributes),
                VisitToken(node.CloseToken));
        }
    }
}

#nullable restore