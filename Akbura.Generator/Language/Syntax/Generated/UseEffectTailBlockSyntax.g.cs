// <auto-generated/>

#nullable enable

using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Collections.Immutable;

namespace Akbura.Language.Syntax.Green
{
    internal abstract partial class GreenUseEffectTailBlockSyntax : global::Akbura.Language.Syntax.Green.GreenNode
    {
        public readonly global::Akbura.Language.Syntax.Green.GreenCSharpBlockSyntax Body;

        protected GreenUseEffectTailBlockSyntax(
            global::Akbura.Language.Syntax.Green.GreenCSharpBlockSyntax body,
            ushort kind,
            ImmutableArray<global::Akbura.Language.Syntax.AkburaDiagnostic>? diagnostics,
            ImmutableArray<global::Akbura.Language.Syntax.AkburaSyntaxAnnotation>? annotations)
            : base(kind, diagnostics, annotations)
        {
            this.Body = body;

            AkburaDebug.Assert(this.Body != null);

            var flags = Flags;
            var fullWidth = FullWidth;

            AdjustWidthAndFlags(Body, ref fullWidth, ref flags);

            SlotCount = 1;
            FullWidth = fullWidth;
            Flags = flags;
        }

        public GreenUseEffectTailBlockSyntax WithBody(global::Akbura.Language.Syntax.Green.GreenCSharpBlockSyntax body)
        {
            return UpdateUseEffectTailBlockSyntax(body);
        }

        public abstract GreenUseEffectTailBlockSyntax UpdateUseEffectTailBlockSyntax(
            global::Akbura.Language.Syntax.Green.GreenCSharpBlockSyntax body);

        public override global::Akbura.Language.Syntax.Green.GreenNode? GetSlot(int index)
        {
            return index switch
            {
                0 => Body,
                _ => null,
            };
        }
    }
}

namespace Akbura.Language.Syntax
{
    internal abstract partial class UseEffectTailBlockSyntax : global::Akbura.Language.Syntax.AkburaSyntax
    {
        protected UseEffectTailBlockSyntax(
            global::Akbura.Language.Syntax.Green.GreenUseEffectTailBlockSyntax greenNode,
            global::Akbura.Language.Syntax.AkburaSyntax? parent,
            int position)
            : base(greenNode, parent, position)
        {
        }

        internal new global::Akbura.Language.Syntax.Green.GreenUseEffectTailBlockSyntax Green
            => Unsafe.As<global::Akbura.Language.Syntax.Green.GreenUseEffectTailBlockSyntax>(base.Green);

        public abstract CSharpBlockSyntax Body { get; }

        public UseEffectTailBlockSyntax WithBody(global::Akbura.Language.Syntax.CSharpBlockSyntax body)
        {
            return UpdateUseEffectTailBlockSyntax(body);
        }

        public abstract UseEffectTailBlockSyntax UpdateUseEffectTailBlockSyntax(
            global::Akbura.Language.Syntax.CSharpBlockSyntax body);

        public override global::Akbura.Language.Syntax.AkburaSyntax? GetNodeSlot(int index)
        {
            return index switch
            {
                0 => Body,
                _ => null,
            };
        }

        public override global::Akbura.Language.Syntax.AkburaSyntax? GetCachedSlot(int index)
        {
            return null;
        }

        public new UseEffectTailBlockSyntax WithLeadingTrivia(SyntaxTriviaList trivia)
        {
            return (UseEffectTailBlockSyntax)base.WithLeadingTrivia(trivia);
        }

        public new UseEffectTailBlockSyntax WithTrailingTrivia(SyntaxTriviaList trivia)
        {
            return (UseEffectTailBlockSyntax)base.WithTrailingTrivia(trivia);
        }
    }
}

#nullable restore