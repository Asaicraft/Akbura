
// ─────────────────────────────────────────────────────────────
// TOKENS  (well-known text; must remain contiguous)
// ─────────────────────────────────────────────────────────────

[id 100]
token InjectKeyword      = "inject";
token ParamKeyword       = "param";
token StateKeyword       = "state";
token UseEffectKeyword   = "useEffect";
token SuppressKeyword    = "suppress";
token CancelKeyword      = "cancel";
token FinallyKeyword     = "finally";
token AsyncKeyword       = "async";
token VoidKeyword        = "void";
token CommandKeyword     = "command"; 

token NewKeyword         = "new";
token ReactListKeyword   = "ReactList";

token IfKeyword          = "if";
token ElseKeyword        = "else";
token ReturnKeyword      = "return";
token ForKeyword         = "for";

token TrueKeyword        = "true"  return true;
token FalseKeyword       = "false" return false;
token NullKeyword        = "null"  return null;

// operators & punctuation
token PlusToken          = "+";
token MinusToken         = "-";
token AsteriskToken      = "*";
token SlashToken         = "/";
token PercentToken       = "%";
token CaretToken         = "^";
token BarToken           = "|";
token AmpersandToken     = "&";
token QuestionToken      = "?";
token ColonToken         = ":";
token SemicolonToken     = ";";
token CommaToken         = ",";
token DotToken           = ".";
token DoubleDotToken     = "..";
token EqualsToken        = "=";
token BangToken          = "!";
token EqualsEqualsToken  = "==";
token BangEqualsToken    = "!=";
token GreaterThanToken   = ">";
token LessThanToken      = "<";
token GreaterEqualsToken = ">=";
token LessEqualsToken    = "<=";
token ArrowToken         = "=>";
token HashToken          = "#";

token OpenBraceToken     = "{";
token CloseBraceToken    = "}";
token OpenBracketToken   = "[";
token CloseBracketToken  = "]";
token OpenParenToken     = "(";
token CloseParenToken    = ")";

// markup tokens
token LessSlashToken     = "</";
token SlashGreaterToken  = "/>";

token SingleQuoteToken   = "'";
token DoubleQuoteToken   = "\"";

token AtToken            = "@";
token BindToken          = "bind";
token InToken            = "in";
token OutToken           = "out";

token UtilitiesKeyword    = "utilities";

[id 200]
/*
    Built-in literal tokens (StringLiteralToken / NumericLiteralToken / etc.)
    already exist at the token layer. Here we only declare DSL-specific
    literals when we want distinct AST-level categories.
*/

// Raw text used as markup content between tags.
literal AkTextLiteral : string;

token CSharpRawToken;


[id 500]

// ─────────────────────────────────────────────────────────────
// BASE NODE ABSTRACTIONS
// ─────────────────────────────────────────────────────────────

/// <summary>
/// Any construct allowed at file top-level (inject/param/state/useEffect/func/markup).
/// Base type AkburaSyntaxNode is implicit.
/// </summary>
abstract node AkTopLevelMember;

// ─────────────────────────────────────────────────────────────
// EMBEDDED C# SYNTAX NODES
// ─────────────────────────────────────────────────────────────

/// <summary>
/// C# type reference (ILogger<T>, int, ReactList<Task>, etc.).
/// Represented as a flat TokenList, left to a C# sub-parser.
/// </summary>
node CSharpTypeSyntax {
    Tokens : TokenList;
}

/// <summary>
/// C# expression fragment.
/// </summary>
node CSharpExpressionSyntax {
    Tokens : TokenList;
}

/// <summary>
/// C# block enclosed in braces: { ... }.
/// </summary>
node CSharpBlockSyntax {
    OpenBrace  : OpenBraceToken;
    Tokens     : TokenList;      // contents without the outer braces
    CloseBrace : CloseBraceToken;
}

/// <summary>
/// Inline expression used in markup: { expr }.
/// </summary>
node InlineExpressionSyntax {
    OpenBrace  : OpenBraceToken;
    Expression : CSharpExpressionSyntax;
    CloseBrace : CloseBraceToken;
}

// ─────────────────────────────────────────────────────────────
// DOCUMENT ROOT
// ─────────────────────────────────────────────────────────────

/// <summary>
/// Entire .akbura compilation unit.
/// </summary>
node AkburaDocumentSyntax {
    Members   : syntaxlist<AkTopLevelMember>;
    /// <summary> 
    /// End-of-file token provided by the host; we reference it as a generic Token.
    /// </summary>
    EndOfFile : Token;
}

// ─────────────────────────────────────────────────────────────
// INJECT / PARAM / STATE / COMMAND DECLARATIONS 
// ─────────────────────────────────────────────────────────────

/// <summary>inject ILogger&lt;ProfileWithTasks&gt; log;</summary>
node InjectDeclarationSyntax : AkTopLevelMember {
    InjectKeyword : InjectKeyword;
    Type          : CSharpTypeSyntax;
    Name          : SimpleName;
    Semicolon     : SemicolonToken;
}

/// <summary>param int UserId = 1; or param out Hello = 10;</summary>
node ParamDeclarationSyntax : AkTopLevelMember {
    ParamKeyword   : ParamKeyword;
    BindingKeyword : OutToken | BindToken;
    Type?          : CSharpTypeSyntax;
    Name           : SimpleName;
    Equals?        : EqualsToken;
    DefaultValue?  : CSharpExpressionSyntax;
    Semicolon      : SemicolonToken;
}

/// <summary>state count = 0; / state ReactList tasks = [];</summary>
node StateDeclarationSyntax : AkTopLevelMember {
    StateKeyword : StateKeyword;
    Type?        : CSharpTypeSyntax;
    Name         : SimpleName;
    Equals       : EqualsToken;
    Initializer  : StateInitializer;
    Semicolon    : SemicolonToken;
}

abstract node StateInitializer
{
    Expression : CSharpExpressionSyntax;
}

node SimpleStateInitializer: StateInitializer;

node BindableStateInitializer: StateInitializer
{
    BindingKeyword : InToken | OutToken | BindToken;
    Expression     : CSharpExpressionSyntax;
}

// ─────────────────────────────────────────────────────────────
// useEffect DECLARATION (+ cancel / finally blocks)
// ─────────────────────────────────────────────────────────────

/// <summary>
/// useEffect($cancel, UserId, tasks) { ... }
/// cancel { ... }
/// finally { ... }
/// </summary>
node UseEffectDeclarationSyntax : AkTopLevelMember {
    UseEffectKeyword : UseEffectKeyword;
    OpenParen        : OpenParenToken;
    // Dependency list: e.g., $cancel, UserId, tasks
    Parameters       : syntaxlist<SimpleName, CommaToken>;
    CloseParen       : CloseParenToken;
    Body             : CSharpBlockSyntax;
    CancelBlock?     : EffectCancelBlockSyntax;
    FinallyBlock?    : EffectFinallyBlockSyntax;
}

node EffectCancelBlockSyntax {
    CancelKeyword : CancelKeyword;
    Body          : CSharpBlockSyntax;
}

node EffectFinallyBlockSyntax {
    FinallyKeyword : FinallyKeyword;
    Body           : CSharpBlockSyntax;
}

/// <summary>
/// Component-level command contract:
///   command int CustomClick(int a);
///
/// Semantics:
///   • No body in syntax – this is a contract, not an implementation.
///   • Exposed as a “command slot” that can be wired from markup:
///       <CustomButton Click={...} />
///   • Inside the component the symbol provides:
///       CustomClick.IsExecuting
///       await CustomClick.Invoke(arg)
///     (both are interpreted at semantic/codegen layer, not by grammar).
/// </summary>
node CommandDeclarationSyntax : AkTopLevelMember {
    CommandKeyword : CommandKeyword;           // "command"
    ReturnType     : CSharpTypeSyntax;         // int / void / etc.
    Name           : SimpleName;               // CustomClick
    OpenParen      : OpenParenToken;           // '('
    Parameters     : syntaxlist<ParameterSyntax, CommaToken>;
    CloseParen     : CloseParenToken;          // ')'
    Semicolon      : SemicolonToken;           // ';'
}

// ─────────────────────────────────────────────────────────────
// FUNCTION DECLARATIONS (async void SaveNew(...){})
// ─────────────────────────────────────────────────────────────

node FunctionDeclarationSyntax : AkTopLevelMember {
    AsyncKeyword? : AsyncKeyword;          // "async" if present
    ReturnType    : CSharpTypeSyntax;      // e.g. "void", "Task", "Task<Result>"
    Name          : SimpleName;
    OpenParen     : OpenParenToken;
    Parameters    : syntaxlist<ParameterSyntax, CommaToken>;
    CloseParen    : CloseParenToken;
    Body          : CSharpBlockSyntax;
}

node ParameterSyntax {
    Type       : CSharpTypeSyntax;
    Identifier : SimpleName;
}

// ─────────────────────────────────────────────────────────────
// MARKUP TREE (Razor-style component markup)
// ─────────────────────────────────────────────────────────────

/// <summary>
/// Base category for all markup-related nodes.
/// </summary>
abstract node MarkupSyntaxNode;

/// <summary>
/// Top-level markup root: a single element at the end of the file.
/// </summary>
node MarkupRootSyntax : AkTopLevelMember {
    Element : MarkupElementSyntax;
}

/// <summary>
/// Base class for any node that can appear inside markup content.
/// </summary>
abstract node MarkupNodeSyntax : MarkupSyntaxNode;

/// <summary>
/// Generic element: &lt;Stack Gap="16"&gt; ... &lt;/Stack&gt;.
/// Allows optional StartTag/EndTag to support fragments and self-closing tags.
/// </summary>
node MarkupElementSyntax : MarkupNodeSyntax {
    StartTag? : MarkupStartTagSyntax;
    Body      : syntaxlist<MarkupContentSyntax>;
    EndTag?   : MarkupEndTagSyntax;
}

/// <summary>
/// Opening tag.
/// </summary>
node MarkupStartTagSyntax : MarkupSyntaxNode {
    LessToken  : LessThanToken;          // "<"
    Name       : SimpleName;        // element name (Stack, Row, Button, ...)
    Attributes : syntaxlist<MarkupAttributeSyntax>;
    // Either ">" or "/>".
    CloseToken : GreaterThanToken | SlashGreaterToken;
}

/// <summary>
/// Closing tag.
/// </summary>
node MarkupEndTagSyntax : MarkupSyntaxNode {
    LessSlashToken : LessSlashToken;     // "</"
    Name           : SimpleName;
    GreaterToken   : GreaterThanToken;  // ">"
}


// ─────────────────────────────────────────────────────────────
// MARKUP CONTENT NODES
// ─────────────────────────────────────────────────────────────

/// <summary>
/// Base type for all markup content forms (text, element, inline expression).
/// </summary>
abstract node MarkupContentSyntax : MarkupNodeSyntax;

/// <summary>
/// Raw text between tags.
/// </summary>
node MarkupTextLiteralSyntax : MarkupContentSyntax {
    TextTokens : syntaxlist<AkTextLiteral>;
}

/// <summary>
/// Nested element content.
/// </summary>
node MarkupElementContentSyntax : MarkupContentSyntax {
    Element : MarkupElementSyntax;
}

/// <summary>
/// Inline expression content: { expr }.
/// </summary>
node MarkupInlineExpressionSyntax : MarkupContentSyntax {
    Expression : InlineExpressionSyntax;
}


// ─────────────────────────────────────────────────────────────
// MARKUP ATTRIBUTES
// ─────────────────────────────────────────────────────────────

/// <summary>
/// Base type for tag attributes.
/// </summary>
abstract node MarkupAttributeSyntax : MarkupSyntaxNode;

/// <summary>
/// Plain attribute: Name="Value".
/// </summary>
node MarkupPlainAttributeSyntax : MarkupAttributeSyntax {
    Name        : SimpleName;
    EqualsToken : EqualsToken;
    Value?      : MarkupAttributeValueSyntax;
}

/// <summary>
/// Prefixed attribute: Prefix:Name="Value"
/// (e.g. bind:Text=..., react={...}, OnClose={...}).
/// </summary>
node MarkupPrefixedAttributeSyntax : MarkupAttributeSyntax {
    Prefix      : BindToken | OutToken;
    Colon       : ColonToken;
    Name        : SimpleName;
    EqualsToken : EqualsToken;
    Value?      : MarkupAttributeValueSyntax;
}

/// <summary>
/// Base type for attribute values.
/// </summary>
abstract node MarkupAttributeValueSyntax : MarkupSyntaxNode;

/// <summary>
/// Literal attribute value, e.g. "User dashboard".
/// </summary>
node MarkupLiteralAttributeValueSyntax : MarkupAttributeValueSyntax {
    Prefix? : MarkupTextLiteralSyntax;
    Value?  : MarkupTextLiteralSyntax;
}

/// <summary>
/// Dynamic attribute value, e.g. { search } or { () => SaveNew() }.
/// </summary>
node MarkupDynamicAttributeValueSyntax : MarkupAttributeValueSyntax {
    Prefix?    : MarkupTextLiteralSyntax;
    Expression : InlineExpressionSyntax;
}

// ─────────────────────────────────────────────────────────────
// Tailwind attributes
// ─────────────────────────────────────────────────────────────

abstract node TailwindAttributeSyntax : MarkupAttributeSyntax;

/// <summary>
/// Base type for a single segment in a composite utility name:
///   border-l-2
///       └─ "l" and "2"
///   p-{a}
///       └─ "{a}"
/// </summary>
abstract node TailwindSegmentSyntax;

node TailwindIdentifierSegmentSyntax : TailwindSegmentSyntax {
    Name : SimpleName;
}

node TailwindNumericSegmentSyntax : TailwindSegmentSyntax {
    Number : NumericLiteralToken;
}

/// <summary>
/// Expression segment: `{a}`, `{width}`, `{vm.Prop}` inside the utility name.
/// Used for patterns like `p-{a}` or `gap-{state * 2}`.
/// </summary>
node TailwindExpressionSegmentSyntax : TailwindSegmentSyntax {
    Expression : InlineExpressionSyntax; // { expr }
}

/// <summary>
/// Simple flag-style utility without a value:
///   flex
///   grid
///   items-center
/// </summary>
node TailwindFlagAttributeSyntax : TailwindAttributeSyntax {
    Name : SimpleName;
}


/// <summary>
/// Base type for a single prefix in:
///   md:w-40
///   in:aw-{width}
///   {state &lt; 10}:h-15
/// </summary>
abstract node TailwindPrefixSegmentSyntax
{
    Colon : ColonToken;
}

/// <summary>
/// Simple conditional prefix:
///   sm:w-40
///   md:h-20
///   lg:flex
/// </summary>
node SimpleConditionalPrefixSyntax : TailwindPrefixSegmentSyntax {
    Name  : SimpleName;   // sm / md / lg / xl / 2xl / etc.
    Colon : ColonToken;   // :
}

/// <summary>
/// Expression-based conditional prefix:
///   {state &lt; 10}:h-15
///   {isMobile}:w-40
/// </summary>
node ExpressionConditionalPrefixSyntax : TailwindPrefixSegmentSyntax {
    Expression : InlineExpressionSyntax; // { expr }
    Colon      : ColonToken;             // :
}


node TailwindFullAttributeSyntax : TailwindAttributeSyntax {
    Prefix?   : TailwindPrefixSegmentSyntax;
    Name      : SimpleName;                                    // aw / w / h / p / etc.
    Minus?    : MinusToken;                                    // null if no segments
    Segments  : syntaxlist<TailwindSegmentSyntax, MinusToken>; // may contain binding segments, e.g. {width}
}

// ─────────────────────────────────────────────────────────────
// AKCSS ROOT
// ─────────────────────────────────────────────────────────────

/// <summary>
/// Root node for a .akcss file.
/// Supports:
///   • class-based style rules: .myclass { ... }, Button.myclass { ... }
///   • @utilities { ... } with parameterized utilities.
/// </summary>
node AkcssDocumentSyntax {
    Members   : syntaxlist<AkcssTopLevelMember>;
    EndOfFile : Token;
}

/// <summary>
/// Any top-level member inside an .akcss file:
///   • style rule: .myclass { ... }
///   • utilities section: @utilities { ... }
/// </summary>
abstract node AkcssTopLevelMember;


// ============================================================================
// SHARED BODY MEMBERS (used by styles and utilities)
// ============================================================================

/// <summary>
/// Base type for any statement inside a style or utility body:
///   • simple assignment: Property : expr;
///   • @if(condition) { ... }
///   • pseudo-state block: @hover { ... }, @hover@checked { ... }
/// Utilities may use the same constructs; invalid combinations
/// are rejected at the semantic layer.
/// </summary>
abstract node AkcssBodyMemberSyntax;

/// <summary>
/// Single property assignment:
///   Background : "Red";
///   Opacity    : 0.5;
///   Width      : width * Spacing;
///
/// Semicolon is optional to allow slightly looser formatting.
/// </summary>
node AkcssAssignmentSyntax : AkcssBodyMemberSyntax {
    PropertyName : SimpleName;            // Background / Opacity / Width / ...
    Colon        : ColonToken;           // ':'
    Expression   : CSharpExpressionSyntax;
    Semicolon?   : SemicolonToken;       // optional ';'
}

/// <summary>
/// Conditional block:
///
///   @if(Property == value) {
///       Background : "Red";
///   }
///
/// Used both in style rules and in utilities. The semantic layer
/// decides how to track the referenced properties / parameters.
/// </summary>
node AkcssIfDirectiveSyntax : AkcssBodyMemberSyntax {
    AtToken    : AtToken;                 // '@'
    IfKeyword  : IfKeyword;               // 'if'
    OpenParen  : OpenParenToken;          // '('
    Condition  : CSharpExpressionSyntax;  // Property == value
    CloseParen : CloseParenToken;         // ')'
    OpenBrace  : OpenBraceToken;          // '{'
    Members    : syntaxlist<AkcssBodyMemberSyntax>;
    CloseBrace : CloseBraceToken;         // '}'
}

/// <summary>
/// Additional pseudo-state segment after the first one:
///   @hover@checked
///        └────── this part
/// </summary>
node AkcssAdditionalPseudoStateSyntax {
    AtToken : AtToken;        // '@'
    State   : SimpleName;     // checked / active / focused / ...
}

/// <summary>
/// Pseudo-state selector:
///   @hover
///   @hover@checked
///
/// Parsed as:
///   AtToken       : '@'
///   FirstState    : SimpleName;  // hover
///   Additional    : syntaxlist<AkcssAdditionalPseudoStateSyntax>;
/// </summary>
node AkcssPseudoSelectorSyntax {
    AtToken    : AtToken;                                // '@'
    FirstState : SimpleName;                             // hover
    Additional : syntaxlist<AkcssAdditionalPseudoStateSyntax>;
}

/// <summary>
/// Pseudo-state block:
///
///   @hover {
///       Background : "LightBlue";
///   }
///
///   @hover@checked {
///       BorderBrush : "Green";
///   }
///
/// Inside are regular AkcssBodyMemberSyntax items (assignments, nested @if, ...).
/// It is mainly meaningful inside style rules; usage inside utilities
/// can be restricted by the semantic layer.
/// </summary>
node AkcssPseudoBlockSyntax : AkcssBodyMemberSyntax {
    Selector  : AkcssPseudoSelectorSyntax;
    OpenBrace : OpenBraceToken;
    Members   : syntaxlist<AkcssBodyMemberSyntax>;
    CloseBrace: CloseBraceToken;
}


// ============================================================================
// AKCSS STYLE RULES (CLASS-BASED STYLES)
// ============================================================================

/// <summary>
/// Style rule:
///   .myclass { ... }
///   Button.myclass { ... }
///
/// Type prefix is optional. When omitted, the rule is treated as global
/// or bound to a default base type (e.g., Control) by the semantic layer.
/// </summary>
node AkcssStyleRuleSyntax : AkcssTopLevelMember {
    Selector  : AkcssStyleSelectorSyntax;
    OpenBrace : OpenBraceToken;
    Members   : syntaxlist<AkcssBodyMemberSyntax>;
    CloseBrace: CloseBraceToken;
}

/// <summary>
/// Selector for style rules:
///
///   .myclass
///   Button.myclass
///
/// Parsed as:
///   TargetType? : Button / Grid / Control / ...
///   DotToken    : '.'
///   Name        : 'myclass'
/// </summary>
node AkcssStyleSelectorSyntax {
    TargetType? : SimpleName;  // optional type prefix: Button / Control / ...
    DotToken    : DotToken;    // '.'
    Name        : SimpleName;  // class name: myclass
}


// ============================================================================
// AKCSS UTILITIES
// ============================================================================

/// <summary>
/// @utilities {
///     .w-(double width) {
///         Width : width * Akbura.Styles.Utilities.Spacing;
///     }
///
///     .someutil-(double a)-(MySuperPuperEnum enam) {
///         @if(enam == MySuperPuperEnum.CoolRadius) {
///             BorderRadius : 1234;
///         }
///     }
///
///     .flag {
///         Opacity : 0.5;
///     }
///
///     Button.btn-(Variant variant) {
///         @if(variant == Variant.Primary) {
///             // ...
///         }
///     }
/// }
///
/// Identifier "utilities" is validated at the semantic layer.
/// </summary>
node AkcssUtilitiesSectionSyntax : AkcssTopLevelMember {
    AtToken        : AtToken;          // '@'
    UtilitiesToken : UtilitiesKeyword; // utilities
    OpenBrace      : OpenBraceToken;   // '{'
    Utilities      : syntaxlist<AkcssUtilityDeclarationSyntax>;
    CloseBrace     : CloseBraceToken;  // '}'
}

/// <summary>
/// Single utility parameter fragment in the selector:
///   .w-(double width)
///   .someutil-(double a)-(MySuperPuperEnum enam)
///
/// Each parameter is prefixed with its own '-' and wrapped in parentheses:
///   - (Type name)
/// </summary>
node AkcssUtilityParameterSyntax {
    Minus     : MinusToken;       // '-'
    OpenParen : OpenParenToken;   // '('
    Type      : CSharpTypeSyntax; // double / Variant / MySuperPuperEnum / ...
    ParamName : SimpleName;       // width / a / variant / enam / ...
    CloseParen: CloseParenToken;  // ')'
}

/// <summary>
/// Unified selector for utilities:
///
///   .flag
///   .w-(double width)
///   .someutil-(double a)-(MySuperPuperEnum enam)
///   Button.btn-(Variant variant)
///
/// Parsed as:
///   TargetType? : Button / Grid / Control / ...
///   DotToken    : '.'
///   Name        : 'flag' / 'w' / 'someutil' / 'btn'
///   Parameters  : [ AkcssUtilityParameterSyntax, ... ]  // may be empty
///
/// When TargetType is omitted (".btn-..."), the semantic layer may treat
/// the utility as applicable to the default base type (e.g., Control).
/// </summary>
node AkcssUtilitySelectorSyntax {
    TargetType? : SimpleName;                        // optional: Button / Control / ...
    DotToken    : DotToken;                          // '.'
    Name        : SimpleName;                        // utility name: w / flag / someutil / btn
    Parameters  : syntaxlist<AkcssUtilityParameterSyntax>;
}

/// <summary>
/// Utility declaration with a selector and a body:
///
///   .w-(double width) {
///       Width : width * Akbura.Styles.Utilities.Spacing;
///   }
///
///   .flag {
///       Opacity : 0.5;
///   }
///
/// Body consists of AkcssBodyMemberSyntax items: assignments, @if, etc.
/// </summary>
node AkcssUtilityDeclarationSyntax {
    Selector  : AkcssUtilitySelectorSyntax;
    OpenBrace : OpenBraceToken;
    Members   : syntaxlist<AkcssBodyMemberSyntax>;
    CloseBrace: CloseBraceToken;
}



// ─────────────────────────────────────────────────────────────
// IDENTIFIERS AND TYPES
// ─────────────────────────────────────────────────────────────

[id 700]
abstract node Type;

abstract node Name: Type;

abstract node SimpleName: Name {
	Identifier: IdentifierToken;
}

node IdentifierName: SimpleName;