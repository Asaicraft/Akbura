using Akbura.Language.Syntax.Green;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Text;
using Microsoft.CodeAnalysis;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Text;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.InteropServices;


namespace Akbura.Language.Syntax;

// <summary>
/// Represents a token in the syntax tree.
/// </summary>
[StructLayout(LayoutKind.Auto)]
[DebuggerDisplay("{GetDebuggerDisplay(), nq}")]
internal readonly struct SyntaxToken : IEquatable<SyntaxToken>
{
    public static readonly Func<SyntaxToken, bool> NonZeroWidth = t => t.Width > 0;
    public static readonly Func<SyntaxToken, bool> Any = t => true;

    /// <summary>
    /// Don't use constructor directly. Use SyntaxFactory.Token instead.
    /// </summary>
    public SyntaxToken(AkburaSyntax? parent, GreenNode? token, int position, int index)
    {
        Debug.Assert(parent == null || !parent.Green.IsList, "list cannot be a parent");
        Debug.Assert(token == null || token.IsToken, "token must be a token");
        Parent = parent;
        Node = token;
        Position = position;
        Index = index;
    }

    /// <summary>
    /// Don't use constructor directly. Use SyntaxFactory.Token instead.
    /// </summary>
    public SyntaxToken(GreenNode? token)
        : this()
    {
        Debug.Assert(token == null || token.IsToken, "token must be a token");
        Node = token;
    }

    private string GetDebuggerDisplay()
    {
        return GetType().Name + " " + (Node != null ? Node.KindText : "None") + " " + ToString();
    }

    /// <summary>
    /// An integer representing the language specific kind of this token.
    /// </summary>
    public ushort RawKind => Node?.RawKind ?? 0;

    public SyntaxKind Kind => Node?.Kind ?? SyntaxKind.None;

    /// <summary>
    /// The node that contains this token in its Children collection.
    /// </summary>
    public AkburaSyntax? Parent { get; }

    public GreenNode? Node { get; }

    public GreenNode RequiredNode
    {
        get
        {
            AkburaDebug.Assert(Node is not null);
            return Node;
        }
    }

    public int Index { get; }

    public int Position { get; }

    /// <summary>
    /// The width of the token in characters, not including its leading and trailing trivia.
    /// </summary>
    public int Width => Node?.Width ?? 0;

    /// <summary>
    /// The complete width of the token in characters including its leading and trailing trivia.
    /// </summary>
    public int FullWidth => Node?.FullWidth ?? 0;

    /// <summary>
    /// The absolute span of this token in characters, not including its leading and trailing trivia.
    /// </summary>
    public TextSpan Span => Node != null ? new(Position + Node.GetLeadingTriviaWidth(), Node.Width) : default;

    public int EndPosition => Node != null ? Position + Node.FullWidth : 0;

    /// <summary>
    /// Same as accessing <see cref="TextSpan.Start"/> on <see cref="Span"/>.
    /// </summary>
    /// <remarks>
    /// Slight performance improvement.
    /// </remarks>
    public int SpanStart => Node != null ? Position + Node.GetLeadingTriviaWidth() : 0;

    /// <summary>
    /// The absolute span of this token in characters, including its leading and trailing trivia.
    /// </summary>
    public TextSpan FullSpan => new(Position, FullWidth);

    /// <summary>
    /// Determines whether this token represents a language construct that was actually parsed from source code.
    /// Missing tokens are typically generated by the parser in error scenarios to represent constructs that should
    /// have been present in the source code for the source code to compile successfully but were actually missing.
    /// </summary>
    public bool IsMissing => Node?.IsMissing ?? false;

    /// <summary>
    /// Returns the value of the token. For example, if the token represents an integer literal, then this property
    /// would return the actual integer.
    /// </summary>
    public object? Value => Node?.GetValue();

    /// <summary>
    /// Returns the text representation of the value of the token. For example, if the token represents an integer
    /// literal, then this property would return a string representing the integer.
    /// </summary>
    public string ValueText => Node?.GetValueText() ?? string.Empty;

    public string Text => ToString();

    /// <summary>
    /// Returns the string representation of this token, not including its leading and trailing trivia.
    /// </summary>
    /// <returns>The string representation of this token, not including its leading and trailing trivia.</returns>
    /// <remarks>The length of the returned string is always the same as Span.Length</remarks>
    public override string ToString()
    {
        return Node != null ? Node.ToString() : string.Empty;
    }

    /// <summary>
    /// Returns the full string representation of this token including its leading and trailing trivia.
    /// </summary>
    /// <returns>The full string representation of this token including its leading and trailing trivia.</returns>
    /// <remarks>The length of the returned string is always the same as FullSpan.Length</remarks>
    public string ToFullString()
    {
        return Node != null ? Node.ToFullString() : string.Empty;
    }

    /// <summary>
    /// Writes the full text of this token to the specified <paramref name="writer"/>.
    /// </summary>
    public void WriteTo(System.IO.TextWriter writer)
    {
        Node?.WriteTo(writer);
    }

    /// <summary>
    /// Writes the text of this token to the specified TextWriter, optionally including trivia.
    /// </summary>
    public void WriteTo(System.IO.TextWriter writer, bool leading, bool trailing)
    {
        Node?.WriteTo(writer, leading, trailing);
    }

    /// <summary>
    /// Determines whether this token has any leading trivia.
    /// </summary>
    public bool HasLeadingTrivia => this.LeadingTrivia.Count > 0;

    /// <summary>
    /// Determines whether this token has any trailing trivia.
    /// </summary>
    public bool HasTrailingTrivia => this.TrailingTrivia.Count > 0;

    /// <summary>
    /// Full width of the leading trivia of this token.
    /// </summary>
    public int LeadingWidth => Node?.GetLeadingTriviaWidth() ?? 0;

    /// <summary>
    /// Full width of the trailing trivia of this token.
    /// </summary>
    public int TrailingWidth => Node?.GetTrailingTriviaWidth() ?? 0;

    /// <summary>
    /// Determines whether this token or any of its descendant trivia have any diagnostics on them. 
    /// </summary>
    public bool ContainsDiagnostics => Node?.ContainsDiagnostics ?? false;


    #region Annotations

    /// <summary>
    /// True if this token or its trivia has any annotations.
    /// </summary>
    public bool ContainsAnnotations => Node?.ContainsAnnotations ?? false;

    /// <summary>
    /// True if this token has annotations of the specified annotation kind.
    /// </summary>
    public bool HasAnnotations(string annotationKind)
    {
        return Node?.HasAnnotations(annotationKind) ?? false;
    }

    /// <summary>
    /// True if this token has annotations of the specified annotation kinds.
    /// </summary>
    public bool HasAnnotations(params string[] annotationKinds)
    {
        return Node?.HasAnnotations(annotationKinds) ?? false;
    }

    /// <summary>
    /// True if this token has the specified annotation.
    /// </summary>
    public bool HasAnnotation([NotNullWhen(true)] AkburaSyntaxAnnotation? annotation)
    {
        return Node?.HasAnnotation(annotation) ?? false;
    }

    /// <summary>
    /// Gets all the annotations of the specified annotation kind.
    /// </summary>
    public IEnumerable<AkburaSyntaxAnnotation> GetAnnotations(string annotationKind)
    {
        return Node?.GetAnnotations(annotationKind) ?? [];
    }

    /// <summary>
    /// Gets all the annotations of the specified annotation kind.
    /// </summary>
    public IEnumerable<AkburaSyntaxAnnotation> GetAnnotations(params string[] annotationKinds)
    {
        return GetAnnotations((IEnumerable<string>)annotationKinds);
    }

    /// <summary>
    /// Gets all the annotations of the specified annotation kind.
    /// </summary>
    public IEnumerable<AkburaSyntaxAnnotation> GetAnnotations(IEnumerable<string> annotationKinds)
    {
        return Node?.GetAnnotations(annotationKinds) ?? [];
    }

    /// <summary>
    /// Adds this annotation to a given syntax token, creating a new syntax token of the same type with the
    /// annotation on it.
    /// </summary>
    public SyntaxToken WithAdditionalAnnotations(params AkburaSyntaxAnnotation[] annotations)
    {
        return WithAdditionalAnnotations((IEnumerable<AkburaSyntaxAnnotation>)annotations);
    }

    /// <summary>
    /// Adds this annotation to a given syntax token, creating a new syntax token of the same type with the
    /// annotation on it.
    /// </summary>
    public SyntaxToken WithAdditionalAnnotations(IEnumerable<AkburaSyntaxAnnotation> annotations)
    {
        if(annotations == null)
        {
            throw new ArgumentNullException(nameof(annotations));
        }

        if (this.Node != null)
        {
            return new SyntaxToken(
                parent: null,
                token: Node.AddAnnotations(annotations),
                position: 0,
                index: 0);
        }

        return default;
    }

    /// <summary>
    /// Creates a new syntax token identical to this one without the specified annotations.
    /// </summary>
    public SyntaxToken WithoutAnnotations(params AkburaSyntaxAnnotation[] annotations)
    {
        return WithoutAnnotations((IEnumerable<AkburaSyntaxAnnotation>)annotations);
    }

    /// <summary>
    /// Creates a new syntax token identical to this one without the specified annotations.
    /// </summary>
    public SyntaxToken WithoutAnnotations(IEnumerable<AkburaSyntaxAnnotation> annotations)
    {
        if(annotations is null)
        {
            throw new ArgumentNullException(nameof(annotations));
        }

        if (this.Node != null)
        {
            return new SyntaxToken(
                parent: null,
                token: Node.WithoutAnnotations(annotations),
                position: 0,
                index: 0);
        }

        return default;
    }

    /// <summary>
    /// Creates a new syntax token identical to this one without annotations of the specified kind.
    /// </summary>
    public SyntaxToken WithoutAnnotations(string annotationKind)
    {
        if(annotationKind == null)
        {
            throw new ArgumentNullException(nameof(annotationKind));
        }

        if (HasAnnotations(annotationKind))
        {
            return WithoutAnnotations(GetAnnotations(annotationKind));
        }

        return this;
    }

    /// <summary>
    /// Copies all SyntaxAnnotations, if any, from this SyntaxToken instance and attaches them to a new instance based on <paramref name="token" />.
    /// </summary>
    /// <remarks>
    /// If no annotations are copied, just returns <paramref name="token" />.
    /// </remarks>
    public SyntaxToken CopyAnnotationsTo(SyntaxToken token)
    {
        if (token.Node == null)
        {
            return default;
        }

        if (Node == null)
        {
            return token;
        }

        var annotations = Node.GetAnnotations();
        if (!annotations.IsDefaultOrEmpty)
        {
            return new SyntaxToken(
                parent: null,
                token: token.Node.AddAnnotations(annotations),
                position: 0,
                index: 0);
        }

        return token;
    }

    #endregion

    /// <summary>
    /// The list of trivia that appear before this token in the source code.
    /// </summary>
    public SyntaxTriviaList LeadingTrivia
    {
        get
        {
            return Node != null
                ? new(this, Node.GetLeadingTrivia(), Position)
                : default;
        }
    }

    /// <summary>
    /// The list of trivia that appear after this token in the source code and are attached to this token or any of
    /// its descendants.
    /// </summary>
    public SyntaxTriviaList TrailingTrivia
    {
        get
        {
            if (Node == null)
            {
                return default;
            }

            var leading = Node.GetLeadingTrivia();
            var index = 0;
            if (leading != null)
            {
                index = leading.IsList ? leading.SlotCount : 1;
            }

            var trailingGreen = Node.GetTrailingTrivia();
            var trailingPosition = Position + FullWidth;
            if (trailingGreen != null)
            {
                trailingPosition -= trailingGreen.FullWidth;
            }

            return new SyntaxTriviaList(this,
                trailingGreen,
                trailingPosition,
                index);
        }
    }

    /// <summary>
    /// Creates a new token from this token with the leading and trailing trivia from the specified token.
    /// </summary>
    public SyntaxToken WithTriviaFrom(SyntaxToken token)
    {
        return WithLeadingTrivia(token.LeadingTrivia).WithTrailingTrivia(token.TrailingTrivia);
    }

    /// <summary>
    /// Creates a new token from this token with the leading trivia specified.
    /// </summary>
    public SyntaxToken WithLeadingTrivia(SyntaxTriviaList trivia)
    {
        return WithLeadingTrivia((IEnumerable<SyntaxTrivia>)trivia);
    }

    /// <summary>
    /// Creates a new token from this token with the leading trivia specified..
    /// </summary>
    public SyntaxToken WithLeadingTrivia(params SyntaxTrivia[]? trivia)
    {
        return this.WithLeadingTrivia((IEnumerable<SyntaxTrivia>?)trivia);
    }

    /// <summary>
    /// Creates a new token from this token with the leading trivia specified.
    /// </summary>
    public SyntaxToken WithLeadingTrivia(IEnumerable<SyntaxTrivia>? trivia)
    {
        return Node != null
            ? new SyntaxToken(null, Node.WithLeadingTrivia(GreenNode.CreateList(trivia, static t => t.RequiredUnderlyingNode)), position: 0, index: 0)
            : default;
    }

    /// <summary>
    /// Creates a new token from this token with the trailing trivia specified.
    /// </summary>
    public SyntaxToken WithTrailingTrivia(SyntaxTriviaList trivia)
    {
        return WithTrailingTrivia((IEnumerable<SyntaxTrivia>)trivia);
    }

    /// <summary>
    /// Creates a new token from this token with the trailing trivia specified.
    /// </summary>
    public SyntaxToken WithTrailingTrivia(params SyntaxTrivia[]? trivia)
    {
        return WithTrailingTrivia((IEnumerable<SyntaxTrivia>?)trivia);
    }

    /// <summary>
    /// Creates a new token from this token with the trailing trivia specified.
    /// </summary>
    public SyntaxToken WithTrailingTrivia(IEnumerable<SyntaxTrivia>? trivia)
    {
        return Node != null
            ? new SyntaxToken(null, Node.WithTrailingTrivia(GreenNode.CreateList(trivia, static t => t.RequiredUnderlyingNode)), position: 0, index: 0)
            : default;
    }

    /// <summary>
    /// Gets a list of all the trivia (both leading and trailing) for this token.
    /// </summary>
    public IEnumerable<SyntaxTrivia> GetAllTrivia()
    {
        if (HasLeadingTrivia)
        {
            if (HasTrailingTrivia)
            {
                return LeadingTrivia.Concat(TrailingTrivia);
            }

            return LeadingTrivia;
        }

        if (HasTrailingTrivia)
        {
            return TrailingTrivia;
        }

        return [];
    }

    /// <summary>
    /// Determines whether two <see cref="SyntaxToken"/>s are equal.
    /// </summary>
    public static bool operator ==(SyntaxToken left, SyntaxToken right)
    {
        return left.Equals(right);
    }

    /// <summary>
    /// Determines whether two <see cref="SyntaxToken"/>s are unequal.
    /// </summary>
    public static bool operator !=(SyntaxToken left, SyntaxToken right)
    {
        return !left.Equals(right);
    }

    /// <summary>
    /// Determines whether the supplied <see cref="SyntaxToken"/> is equal to this
    /// <see cref="SyntaxToken"/>.
    /// </summary>
    public bool Equals(SyntaxToken other)
    {
        return Parent == other.Parent &&
               Node == other.Node &&
               Position == other.Position &&
               Index == other.Index;
    }

    /// <summary>
    /// Determines whether the supplied <see cref="SyntaxToken"/> is equal to this
    /// <see cref="SyntaxToken"/>.
    /// </summary>
    public override bool Equals(object? obj)
    {
        return obj is SyntaxToken token && Equals(token);
    }

    /// <summary>
    /// Serves as hash function for <see cref="SyntaxToken"/>.
    /// </summary>
    public override int GetHashCode()
    {
        return HashCode.Combine(Parent, Node, Position, Index);
    }

    /// <summary>
    /// Gets a list of all the diagnostics associated with this token and any related trivia.
    /// This method does not filter diagnostics based on #pragmas and compiler options
    /// like nowarn, warnaserror etc.
    /// </summary>
    public ImmutableArray<AkburaDiagnostic> GetDiagnostics()
    {
        if (Node == null)
        {
            return [];
        }

        var diagnostics = Node.GetDiagnostics();

        return diagnostics;
    }

    /// <summary>
    /// Determines if this token is equivalent to the specified token.
    /// </summary>
    public bool IsEquivalentTo(SyntaxToken token)
    {
        return
            (Node == null && token.Node == null) ||
            (Node != null && token.Node != null && Node.IsEquivalentTo(token.Node));
    }

    /// <summary>
    /// Returns true if these two tokens are considered "incrementally identical".  An incrementally identical token
    /// occurs when a <see cref="SyntaxTree"/> is incrementally parsed using <see cref="SyntaxTree.WithChangedText"/>
    /// and the incremental parser is able to take the token from the original tree and use it in its entirety in the
    /// new tree.  In this case, the <see cref="SyntaxToken.ToFullString()"/> of each token will be the same, though 
    /// they could have different parents, and may occur at different positions in the respective trees.  If two tokens are
    /// incrementally identical, all trivial of each node will be incrementally identical as well.
    /// </summary>
    /// <remarks>
    /// Incrementally identical tokens can also appear within the same syntax tree, or syntax trees that did not arise
    /// from <see cref="SyntaxTree.WithChangedText"/>.  This can happen as the parser is allowed to construct parse
    /// trees using shared tokens for efficiency.  In all these cases though, it will still remain true that the incrementally
    /// identical tokens could have different parents and may occur at different positions in their respective trees.
    /// </remarks>
    public bool IsIncrementallyIdenticalTo(SyntaxToken token)
        => Node != null && Node == token.Node;
}